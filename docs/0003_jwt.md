# JWT Authentication Implementation Guide

## Overview

This guide provides a minimal JWT-based authentication system for your FastAPI backend and React TypeScript frontend. This solution addresses the "multiple users" requirement without over-engineering the system.

## Backend Implementation (FastAPI)

### Dependencies

First, install the required packages:

```bash
pip install python-jose[cryptography] passlib[bcrypt]
```

### JWT Configuration and Helpers

```python
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jose import JWTError, jwt
from passlib.context import CryptContext
from pydantic import BaseModel
from datetime import datetime, timedelta
import motor.motor_asyncio

# Configuration
SECRET_KEY="your-secret-key"  # Use environment variable in production
ALGORITHM="HS256"
ACCESS_TOKEN_EXPIRE_MINUTES=30

# Setup
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

class User(BaseModel):
    username: str

# MongoDB collections (assuming your client is already set up)
users_collection = db.users  # Your existing db instance
```

### Authentication Functions

```python
async def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

async def get_user(username: str):
    user = await users_collection.find_one({"username": username})
    if user:
        return {"username": user["username"], "hashed_password": user["hashed_password"]}
    return None

async def authenticate_user(username: str, password: str):
    user = await get_user(username)
    if not user or not await verify_password(password, user["hashed_password"]):
        return False
    return User(username=username)

def create_access_token(data: dict, expires_delta: timedelta = None):
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

async def get_current_user(token: str = Depends(oauth2_scheme)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        return User(username=username)
    except JWTError:
        raise credentials_exception
```

### Login Endpoint

```python
@app.post("/token")
async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):
    user = await authenticate_user(form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}
```

### Protecting Your Existing Endpoints

Add authentication to your existing rag endpoints:

```python
# Example: Protect your existing rag endpoints
@app.get("/rag")
async def rag_query(
    request: RAGQueryRequest,
    rag_service: RAGService = Depends(get_rag_service), current_user: User = Depends(get_current_user)
) -> RAGResponse:
    pass
```

### Create Test Users

Add a few test users to your MongoDB users collection:

```python
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# Run this once to create test users
async def create_test_users():
    test_users = [
        {"username": "vet1", "hashed_password": pwd_context.hash("password123")},
        {"username": "vet2", "hashed_password": pwd_context.hash("password123")},
        {"username": "tech1", "hashed_password": pwd_context.hash("password123")},
    ]
    
    for user in test_users:
        await users_collection.insert_one(user)
```

## Frontend Implementation (React TypeScript)

### Login Component

```tsx
import React, { useState } from 'react';
import axios from 'axios';

interface LoginProps {
  onLoginSuccess: () => void;
}

const Login: React.FC<LoginProps> = ({ onLoginSuccess }) => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    try {
      const formData = new FormData();
      formData.append('username', username);
      formData.append('password', password);

      const response = await axios.post('/token', formData, {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
      });

      localStorage.setItem('token', response.data.access_token);
      localStorage.setItem('username', username);
      onLoginSuccess();
    } catch (error) {
      setError('Invalid username or password');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="login-container">
      <form onSubmit={handleLogin} className="login-form">
        <h2>Login</h2>
        {error && <div className="error-message">{error}</div>}
        
        <div className="form-group">
          <input
            type="text"
            value={username}
            onChange={(e) => setUsername(e.target.value)}
            placeholder="Username"
            required
            disabled={loading}
          />
        </div>
        
        <div className="form-group">
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            placeholder="Password"
            required
            disabled={loading}
          />
        </div>
        
        <button type="submit" disabled={loading}>
          {loading ? 'Logging in...' : 'Login'}
        </button>
        
        <div className="test-credentials">
          <small>Test credentials: doctor1/password123, doctor2/password123, nurse1/password123</small>
        </div>
      </form>
    </div>
  );
};

export default Login;
```

### Axios Interceptor for Authentication

Set up automatic token inclusion in requests:

```tsx
import axios from 'axios';

// Set up axios interceptor to include token in all requests
axios.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Handle 401 responses (token expired)
axios.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      localStorage.removeItem('token');
      localStorage.removeItem('username');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);
```

### Authentication State Management

```tsx
import React, { useState, useEffect, createContext, useContext } from 'react';

interface AuthContextType {
  isAuthenticated: boolean;
  username: string | null;
  logout: () => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [username, setUsername] = useState<string | null>(null);

  useEffect(() => {
    const token = localStorage.getItem('token');
    const storedUsername = localStorage.getItem('username');
    
    if (token && storedUsername) {
      setIsAuthenticated(true);
      setUsername(storedUsername);
    }
  }, []);

  const logout = () => {
    localStorage.removeItem('token');
    localStorage.removeItem('username');
    setIsAuthenticated(false);
    setUsername(null);
  };

  return (
    <AuthContext.Provider value={{ isAuthenticated, username, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
```

### App Component with Auth

```tsx
import React from 'react';
import { AuthProvider, useAuth } from './auth/AuthContext';
import Login from './components/Login';
import PatientPortal from './components/PatientPortal'; // Your existing app

const AppContent: React.FC = () => {
  const { isAuthenticated, username, logout } = useAuth();

  if (!isAuthenticated) {
    return <Login onLoginSuccess={() => window.location.reload()} />;
  }

  return (
    <div className="app">
      <header className="app-header">
        <h1>AI Visit Summary Portal</h1>
        <div className="user-info">
          <span>Welcome, {username}</span>
          <button onClick={logout} className="logout-btn">Logout</button>
        </div>
      </header>
      <PatientPortal />
    </div>
  );
};

const App: React.FC = () => {
  return (
    <AuthProvider>
      <AppContent />
    </AuthProvider>
  );
};

export default App;
```

## Testing

1. **Create Test Users**: Run the `create_test_users()` function once to seed your database
2. **Test Login**: Use credentials like `doctor1/password123`
3. **Test Protection**: Try accessing patient endpoints without logging in (should get 401)
4. **Test Multi-User**: Open two browser tabs with different users to verify they can both access the system

## Security Notes

- Store `SECRET_KEY` in environment variables for production
- Consider token refresh mechanisms for longer sessions
- Use HTTPS in production
- This is a minimal implementation focused on the assessment requirements

## Integration with Existing Code

1. Add the authentication endpoints and middleware above
2. Protect your existing patient routes with `Depends(get_current_user)`
3. Add the login component to your frontend
4. Set up the axios interceptor for automatic token handling

The authentication system will work seamlessly with your existing patient data editing and AI summary generation.


# IMPORTANT
1. all pages should be OPEN except for the rag search - this depends on login
2. do not change the route / 
3. make a new /signup endpoint