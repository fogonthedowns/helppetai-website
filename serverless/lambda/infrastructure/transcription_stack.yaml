AWSTemplateFormatVersion: '2010-09-09'
Description: 'Audio transcription service with S3 trigger and webhook notification'

Parameters:
  AudioBucketName:
    Type: String
    Description: Name for the S3 bucket that will store audio files
    Default: my-audio-transcription-bucket
    
  WebhookEndpointUrl:
    Type: String
    Description: URL endpoint to POST transcription results
    Default: https://your-api.com/webhook/transcription
    
  WebhookAuthHeader:
    Type: String
    Description: Optional authentication header name (e.g., Authorization, X-API-Key)
    Default: ""
    
  WebhookAuthValue:
    Type: String
    Description: Optional authentication header value
    Default: ""
    NoEcho: true

Resources:
  # S3 Bucket for audio files
  AudioBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Ref AudioBucketName
      NotificationConfiguration:
        LambdaConfigurations:
          - Event: s3:ObjectCreated:*
            Function: !GetAtt AudioProcessorFunction.Arn
            Filter:
              S3Key:
                Rules:
                  - Name: suffix
                    Value: .m4a
          - Event: s3:ObjectCreated:*
            Function: !GetAtt AudioProcessorFunction.Arn
            Filter:
              S3Key:
                Rules:
                  - Name: suffix
                    Value: .mp3
      PublicReadPolicy: false
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256

  # IAM Role for Audio Processor Lambda
  AudioProcessorRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3AccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                Resource:
                  - !Sub '${AudioBucket}/*'
              - Effect: Allow
                Action:
                  - s3:ListBucket
                Resource:
                  - !Ref AudioBucket
        - PolicyName: TranscribeAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - transcribe:StartTranscriptionJob
                  - transcribe:GetTranscriptionJob
                  - transcribe:ListTranscriptionJobs
                  - transcribe:TagResource
                Resource: '*'

  # IAM Role for Transcription Complete Lambda
  TranscriptionCompleteRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: TranscribeAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - transcribe:GetTranscriptionJob
                  - transcribe:ListTagsForResource
                Resource: '*'
        - PolicyName: S3AccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                Resource: '*'

  # Lambda function for processing audio files
  AudioProcessorFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: audio-transcription-processor
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt AudioProcessorRole.Arn
      Timeout: 300
      Environment:
        Variables:
          TRANSCRIPTION_OUTPUT_BUCKET: !Ref AudioBucket
      Code:
        ZipFile: |
          # Paste the first Lambda function code here
          import json
          import boto3
          import urllib.parse
          import os
          import uuid
          from datetime import datetime

          s3_client = boto3.client('s3')
          transcribe_client = boto3.client('transcribe')

          def lambda_handler(event, context):
              try:
                  for record in event['Records']:
                      bucket = record['s3']['bucket']['name']
                      key = urllib.parse.unquote_plus(record['s3']['object']['key'], encoding='utf-8')
                      
                      print(f"Processing file: {key} from bucket: {bucket}")
                      
                      if not is_supported_audio_format(key):
                          print(f"Unsupported file format: {key}")
                          continue
                      
                      job_name = create_transcription_job(bucket, key)
                      
                      if job_name:
                          print(f"Started transcription job: {job_name}")
                      else:
                          print(f"Failed to start transcription for: {key}")
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps('Processing completed successfully')
                  }
                  
              except Exception as e:
                  print(f"Error processing event: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps(f'Error: {str(e)}')
                  }

          def is_supported_audio_format(file_key):
              supported_formats = ['.m4a', '.mp3', '.wav', '.flac']
              return any(file_key.lower().endswith(fmt) for fmt in supported_formats)

          def create_transcription_job(bucket, key):
              try:
                  timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                  file_name = key.split('/')[-1].split('.')[0]
                  job_name = f"transcribe_{file_name}_{timestamp}_{str(uuid.uuid4())[:8]}"
                  
                  media_uri = f"s3://{bucket}/{key}"
                  
                  if key.lower().endswith('.m4a'):
                      media_format = 'm4a'
                  elif key.lower().endswith('.mp3'):
                      media_format = 'mp3'
                  elif key.lower().endswith('.wav'):
                      media_format = 'wav'
                  elif key.lower().endswith('.flac'):
                      media_format = 'flac'
                  else:
                      media_format = 'mp3'
                  
                  output_bucket = os.environ.get('TRANSCRIPTION_OUTPUT_BUCKET', bucket)
                  output_key = f"transcriptions/{file_name}_{timestamp}.json"
                  
                  response = transcribe_client.start_transcription_job(
                      TranscriptionJobName=job_name,
                      Media={'MediaFileUri': media_uri},
                      MediaFormat=media_format,
                      LanguageCode='en-US',
                      OutputBucketName=output_bucket,
                      OutputKey=output_key,
                      Settings={
                          'ShowSpeakerLabels': True,
                          'MaxSpeakerLabels': 10,
                          'ShowAlternatives': True,
                          'MaxAlternatives': 3
                      },
                      Tags=[
                          {
                              'Key': 'OriginalFileKey',
                              'Value': key
                          },
                          {
                              'Key': 'OriginalBucket',
                              'Value': bucket
                          }
                      ]
                  )
                  
                  return job_name
                  
              except Exception as e:
                  print(f"Error creating transcription job: {str(e)}")
                  return None

  # Lambda function for handling transcription completion
  TranscriptionCompleteFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: transcription-complete-handler
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt TranscriptionCompleteRole.Arn
      Timeout: 300
      Environment:
        Variables:
          WEBHOOK_ENDPOINT_URL: !Ref WebhookEndpointUrl
          WEBHOOK_AUTH_HEADER: !Ref WebhookAuthHeader
          WEBHOOK_AUTH_VALUE: !Ref WebhookAuthValue
      Layers:
        - arn:aws:lambda:us-east-1:770693421928:layer:Klayers-p39-requests:5  # requests layer
      Code:
        ZipFile: |
          # Paste the second Lambda function code here
          import json
          import boto3
          import requests
          import os
          from urllib.parse import urlparse

          transcribe_client = boto3.client('transcribe')
          s3_client = boto3.client('s3')

          def lambda_handler(event, context):
              try:
                  detail = event.get('detail', {})
                  job_name = detail.get('TranscriptionJobName')
                  job_status = detail.get('TranscriptionJobStatus')
                  
                  print(f"Processing transcription job: {job_name}, Status: {job_status}")
                  
                  if job_status != 'COMPLETED':
                      print(f"Job not completed successfully: {job_status}")
                      return {
                          'statusCode': 200,
                          'body': json.dumps(f'Job status: {job_status}')
                      }
                  
                  job_response = transcribe_client.get_transcription_job(
                      TranscriptionJobName=job_name
                  )
                  
                  job_info = job_response['TranscriptionJob']
                  transcript_uri = job_info['Transcript']['TranscriptFileUri']
                  
                  original_file_key = None
                  original_bucket = None
                  
                  tags_response = transcribe_client.list_tags_for_resource(
                      ResourceArn=job_info['TranscriptionJobArn']
                  )
                  
                  for tag in tags_response.get('Tags', []):
                      if tag['Key'] == 'OriginalFileKey':
                          original_file_key = tag['Value']
                      elif tag['Key'] == 'OriginalBucket':
                          original_bucket = tag['Value']
                  
                  transcript_content = download_transcript(transcript_uri)
                  
                  if transcript_content:
                      webhook_success = post_to_webhook(
                          original_file_key, 
                          original_bucket,
                          transcript_content,
                          job_name
                      )
                      
                      if webhook_success:
                          print(f"Successfully posted results for job: {job_name}")
                      else:
                          print(f"Failed to post webhook for job: {job_name}")
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps('Transcription processing completed')
                  }
                  
              except Exception as e:
                  print(f"Error processing transcription completion: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps(f'Error: {str(e)}')
                  }

          def download_transcript(transcript_uri):
              try:
                  parsed_uri = urlparse(transcript_uri)
                  bucket = parsed_uri.netloc
                  key = parsed_uri.path.lstrip('/')
                  
                  response = s3_client.get_object(Bucket=bucket, Key=key)
                  transcript_json = json.loads(response['Body'].read().decode('utf-8'))
                  
                  return transcript_json
                  
              except Exception as e:
                  print(f"Error downloading transcript: {str(e)}")
                  return None

          def post_to_webhook(original_file_key, original_bucket, transcript_content, job_name):
              try:
                  webhook_url = os.environ.get('WEBHOOK_ENDPOINT_URL')
                  
                  if not webhook_url:
                      print("No webhook URL configured")
                      return False
                  
                  transcript_text = ""
                  if 'results' in transcript_content and 'transcripts' in transcript_content['results']:
                      transcripts = transcript_content['results']['transcripts']
                      if transcripts:
                          transcript_text = transcripts[0].get('transcript', '')
                  
                  payload = {
                      'originalFileKey': original_file_key,
                      'originalBucket': original_bucket,
                      'jobName': job_name,
                      'transcriptText': transcript_text,
                      'fullTranscriptData': transcript_content,
                      'timestamp': transcript_content.get('jobName', ''),
                      'status': 'completed'
                  }
                  
                  headers = {
                      'Content-Type': 'application/json'
                  }
                  
                  webhook_auth_header = os.environ.get('WEBHOOK_AUTH_HEADER')
                  webhook_auth_value = os.environ.get('WEBHOOK_AUTH_VALUE')
                  
                  if webhook_auth_header and webhook_auth_value:
                      headers[webhook_auth_header] = webhook_auth_value
                  
                  response = requests.post(
                      webhook_url,
                      json=payload,
                      headers=headers,
                      timeout=30
                  )
                  
                  if response.status_code == 200:
                      print(f"Webhook POST successful: {response.status_code}")
                      return True
                  else:
                      print(f"Webhook POST failed: {response.status_code}, {response.text}")
                      return False
                      
              except Exception as e:
                  print(f"Error posting to webhook: {str(e)}")
                  return False

  # Permission for S3 to invoke Lambda
  S3InvokeLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref AudioProcessorFunction
      Action: lambda:InvokeFunction
      Principal: s3.amazonaws.com
      SourceAccount: !Ref 'AWS::AccountId'
      SourceArn: !Sub '${AudioBucket}/*'

  # EventBridge Rule for Transcribe job completion
  TranscribeJobCompleteRule:
    Type: AWS::Events::Rule
    Properties:
      Description: 'Capture AWS Transcribe job completion events'
      EventPattern:
        source:
          - aws.transcribe
        detail-type:
          - Transcribe Job State Change
        detail:
          TranscriptionJobStatus:
            - COMPLETED
            - FAILED
      State: ENABLED
      Targets:
        - Arn: !GetAtt TranscriptionCompleteFunction.Arn
          Id: TranscriptionCompleteTarget

  # Permission for EventBridge to invoke Lambda
  EventBridgeInvokeLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref TranscriptionCompleteFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt TranscribeJobCompleteRule.Arn

Outputs:
  AudioBucketName:
    Description: Name of the S3 bucket for audio files
    Value: !Ref AudioBucket
    
  AudioProcessorFunctionArn:
    Description: ARN of the audio processor Lambda function
    Value: !GetAtt AudioProcessorFunction.Arn
    
  TranscriptionCompleteFunctionArn:
    Description: ARN of the transcription complete handler Lambda function
    Value: !GetAtt TranscriptionCompleteFunction.Arn